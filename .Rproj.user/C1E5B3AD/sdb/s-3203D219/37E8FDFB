{
    "contents" : "## Toolkit ##\n## 有不少例子可以看看 ##\n## import library ##\nlibrary('ggplot2')\nlibrary('scales')\nlibrary('hexbin')\ndsmall <- diamonds[sample(nrow(diamonds), 300),]\ndf <- data.frame(\n  x <- c(3, 1, 5),\n  y <- c(2, 4, 5),\n  label <- c('a', 'b', 'c'))\n\np <- ggplot(df, aes(x, y))+xlab(NULL)+ylab(NULL)\np + geom_point() + labs(title='geom point')\np + geom_line() + labs(title='geom line')\np + geom_bar(stat='identity') + labs(title='geom_bar(stat=\\'identity\\')') \np + geom_area() + labs(title='geom_area')\np + geom_path() + labs(title='geom_path')\np + geom_text(aes(label=label)) + labs(title='geom_text')\np + geom_tile() + labs(title='geom_tile')\np + geom_polygon() + labs(title='geom_polygon')\n\n## Distribution Visualization ##\n## histogram and freqpoly use stat='bin' as default, so there are two variables automatic computed.\n## 'count' and 'density', density almost equal count/total number of count ##\ndepth_dist <- ggplot(diamonds, aes(depth)) + xlim(58, 68)\ndepth_dist + geom_histogram(aes(y=..density..), binwidth=0.1) + facet_grid(cut ~ .)\ndepth_dist + geom_histogram(aes(fill=cut), binwidth=0.1, position='fill')\ndepth_dist + geom_freqpoly(aes(y=..density.., col=cut), binwidth=0.1)\n\n## geom_boxplot = stat_boxplot + geom_boxplot, 连续型变量要先进行封箱(bin)操作再进行boxplot\nlibrary(plyr)\n## 离散型变量的boxplot ##\nqplot(cut, depth, data=diamonds, geom='boxplot')\n\n## 对连续型变量，使用 round_any 进行封箱(bin)处理后，并指定group，绘制boxplot。round_any是一种精确度限制\n## 的模式，round_any(carat, 0.1, floor)， 是将carat的精度限制在0.1，这样天然形成bin\nqplot(carat, depth, data=diamonds, geom='boxplot', group=round_any(carat, 0.1, floor), xlim=c(0,3))\n\n## geom_jitter = position_jitter + geom_point, 在离散型变量分布上绘制随机噪声点，以解决遮盖问题 ##\nqplot(class, cty, data=mpg, geom='jitter')\nqplot(class, drv, data=mpg, geom='jitter')\n\n## geom_density=stat_density + geom_area，基于核平滑方法进行平滑后得到都多边形， 请在一直密度函数连续、\n## 平滑、无界的情况下使用。实际上，是直方图的平滑版本，虽然有良好的理论性质，但很难由图回溯到数据。\nqplot(depth, data=diamonds, geom='density', xlim=c(54, 70))\nqplot(depth, data=diamonds, geom='density', xlim=c(54, 70), fill=cut, alpha=I(0.2))\n\n## overplotting 问题处理 ##\ndf <- data.frame(x=rnorm(2000), y=rnorm(2000))\nnorm <- ggplot(df, aes(x, y))\nnorm + geom_point()\nnorm + geom_point(shape=1)\nnorm + geom_point(shape='.')\n## 使用alpha来解决一部分遮盖问题，但由于alpha的比值是指多少次重叠为不透明，而且R最多支持1/256\n## 所以很容易不够。\nnorm + geom_point(col='black', alpha=1/10)\nnorm + geom_point(col='black', alpha=1/3)\n\n## jitter的技巧：如果变量稍微有点离散，那么jitter可能会在边界流出空白，更便于监测。\n## position_jitter 从图上看，应该是将部分点平移了。具体待查。\ntd <- ggplot(diamonds, aes(table, depth)) + xlim(50, 70) + ylim(50, 70)\ntd + geom_point()\ntd + geom_jitter()\njit <- position_jitter(width = 0.9)\ntd + geom_jitter(position=jit)\ntd + geom_jitter(position=jit, col='black', alpha=0.1)\ntd + geom_jitter(position=jit, col='black', alpha=0.05)\ntd + geom_jitter(position=jit, col='black', alpha=1/200)\n\n## 上面的做法感觉是二维核密度估计， 所以我们可以尝试先统计分箱中点的数量， 然后用图形表达出来\n## 选择六边形。\nd <- ggplot(diamonds, aes(carat, price)) + xlim(1, 3) + theme(legend.position=\"none\")\nd + stat_bin2d()\nd + stat_bin2d(bins=10)\nd + stat_bin2d(binwidth=c(0.02, 200))\nd + stat_binhex()\nd + stat_binhex(bins=10)\nd + stat_binhex(binwidth=c(0.02, 200))\nd + geom_point() + geom_density2d()\nd + stat_density2d(geom='point', aes(size=..density..), contour=F,) + scale_size_area()\nd + stat_density2d(geom='tile', aes(fill = ..density..), contour=F)\nlast_plot() + scale_fill_gradient(limits=c(1e-5, 8e-4))\n\n## Map Visual ##\nlibrary(maps)\ndata(us.cities)\nbig_cities <- subset(us.cities, pop>500000)\nqplot(long, lat, data=big_cities) + borders(\"state\", size=0.1)+geom_text(label=big_cities$name)\n\ntx_cities <- subset(us.cities, country.etc=='TX')\nggplot(tx_cities, aes(long,lat)) + borders(\"county\", \"texas\", col='gray70') + geom_point(col='black', alpha=0.5)\n\n## choropleth map ##\n## 使用特定的列将地图数据和实际数据结合（使用merge函数）##\n\nstates <- map_data('state')\narrests <- USArrests\nnames(arrests) <- tolower(names(arrests))\narrests$region <- tolower(rownames(USArrests))\nchoro <- merge(states, arrests, by='region')\nchoro <- choro[order(choro$order),]\nqplot(long, lat, data=choro, group=group, fill=assault, geom='polygon')\nqplot(long, lat, data=choro, group=group, fill=assault/murder, geom='polygon')\n\n## 需要用到 library(plyr) ##\n## ddply(.data, .variables, .func=NULL) 其中： ##\n## .data是默认数据集， .variables是用来做处理的分组变量. .func是对应的函数 ##\n## 下面的例子里，ddply(ia, .(subregion), colwise(mid_range, .(lat, long)))中： ##\n## ia数据框的subregion变量为分组变量（group），使用colwise对所有subregion相同的 ##\n## 数据样本分别求其经纬度的平均值， 该值就是subregion组的平均值。 ##\n## 对应到数据含义中，subregion是郡名， 所以centres其实就是某个郡的中心。  ##\n## ---------------------------------------------------------------------  ##\n## 从ggplot绘图过程中，可以看出同时使用两个数据集做图，那么需要aes中某些变量名一致 ##\n## 测试时添加了几个变量:\"lat1, long1, ooo\", 根据变量名去掉这些列时，使用了match函数 ##\n## ia[, -match(delete.names, colnames(ia))] ##\n\nlibrary(plyr)\nia <- map_data('county', 'iowa')\nmid_range <- function(x) {\n  mean(range(x, na.rm=T))\n}\ncentres <- ddply(ia, .(subregion), colwise(mid_range, .(lat, long)))\nggplot(ia, aes(lat, long)) + geom_polygon(aes(group=group), fill=NA, col='gray70') + geom_text(aes(lat1, long1, label=subregion), data=centres, size=3, angle=45)\n\n## 揭示不确定性 ##\n## rbinom(nrow(diamonds), 1, 0.2) 意思是 二项分布中1的概率是0.2 ##\n## d 都使用方式其实等同于 20% 抽样 ##\n\nd <- subset(diamonds, carat<2.5 & rbinom(nrow(diamonds), 1, 0.2) == 1)\nd$lcarat <- log(d$carat)\nd$lprice <- log(d$price)\nmodel <- lm(lprice ~ lcarat, data=d)\n## 去线性回归残差值为新的Y，其实是指预测值无法被线性关系解释的部分（剔除线性关系后的变量自变量 ##\n## 关系 ##\nd$lprice2 <- resid(model)\nmod <- lm(lprice2 ~ lcarat*color, data=d)\nlibrary(effects)\n",
    "created" : 1418356176055.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3380680294",
    "id" : "37E8FDFB",
    "lastKnownWriteTime" : 1418727964,
    "path" : "~/Learning/R/ggplot/Ch5.R",
    "project_path" : "Ch5.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}